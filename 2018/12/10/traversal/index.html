<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="leetcode,DFS,BFS," />










<meta name="description" content="深度优先遍历（DFS）和广度优先遍历（BFS）是在树和图算法中至关重要。两者虽同样作为遍历算法，也有不同的应用场景。DFS 与栈密切相关；BFS 与队列密切相关。">
<meta name="keywords" content="leetcode,DFS,BFS">
<meta property="og:type" content="article">
<meta property="og:title" content="[LeetCode] Traversal">
<meta property="og:url" content="https://xfge.github.io/2018/12/10/traversal/index.html">
<meta property="og:site_name" content="This is Sheffield!">
<meta property="og:description" content="深度优先遍历（DFS）和广度优先遍历（BFS）是在树和图算法中至关重要。两者虽同样作为遍历算法，也有不同的应用场景。DFS 与栈密切相关；BFS 与队列密切相关。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://xfge.github.io/images/2018/12/dfs-struct.png">
<meta property="og:image" content="https://xfge.github.io/images/2018/12/dfs-time.png">
<meta property="og:image" content="https://xfge.github.io/images/2018/12/mht.jpeg">
<meta property="og:updated_time" content="2018-12-10T07:01:19.871Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="[LeetCode] Traversal">
<meta name="twitter:description" content="深度优先遍历（DFS）和广度优先遍历（BFS）是在树和图算法中至关重要。两者虽同样作为遍历算法，也有不同的应用场景。DFS 与栈密切相关；BFS 与队列密切相关。">
<meta name="twitter:image" content="https://xfge.github.io/images/2018/12/dfs-struct.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":true,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://xfge.github.io/2018/12/10/traversal/"/>





  <title>[LeetCode] Traversal | This is Sheffield!</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">This is Sheffield!</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Code here!</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xfge.github.io/2018/12/10/traversal/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sheffield">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="This is Sheffield!">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">[LeetCode] Traversal</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-10T00:00:00+08:00">
                2018-12-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS/" itemprop="url" rel="index">
                    <span itemprop="name">CS</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS/LeetCode/" itemprop="url" rel="index">
                    <span itemprop="name">LeetCode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>深度优先遍历（DFS）和广度优先遍历（BFS）是在树和图算法中至关重要。两者虽同样作为遍历算法，也有不同的应用场景。DFS 与栈密切相关；BFS 与队列密切相关。</p>
<a id="more"></a>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><h3 id="BFS-与队列"><a href="#BFS-与队列" class="headerlink" title="BFS 与队列"></a>BFS 与队列</h3><p>除了遍历树或图，BFS 的一个典型应用是<strong>找到最短路径</strong>。以下是一个典型的 BFS 代码框架，其中加入了对已访问节点的记录以防陷入死循环。如果确保遍历的图是无环图，或者希望多次访问节点，那么可以略去这一步骤。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the length of the shortest path between root and target node.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(Node root, Node target)</span> </span>&#123;</span><br><span class="line">    Queue&lt;Node&gt; queue;  <span class="comment">// store all nodes which are waiting to be processed</span></span><br><span class="line">    Set&lt;Node&gt; used;     <span class="comment">// store all the used nodes</span></span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>;       <span class="comment">// number of steps neeeded from root to current node</span></span><br><span class="line">    <span class="comment">// initialize</span></span><br><span class="line">    add root to queue;</span><br><span class="line">    add root to used;</span><br><span class="line">    <span class="comment">// BFS</span></span><br><span class="line">    <span class="keyword">while</span> (queue is not empty) &#123;</span><br><span class="line">        step = step + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// iterate the nodes which are already in the queue</span></span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            Node cur = the first node in queue;</span><br><span class="line">            <span class="keyword">return</span> step <span class="keyword">if</span> cur is target;</span><br><span class="line">            <span class="keyword">for</span> (Node next : the neighbors of cur) &#123;</span><br><span class="line">                <span class="keyword">if</span> (next is not in used) &#123;</span><br><span class="line">                    add next to queue;</span><br><span class="line">                    add next to used;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            remove the first node from queue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;          <span class="comment">// there is no path from root to target</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><h3 id="DFS-与栈"><a href="#DFS-与栈" class="headerlink" title="DFS 与栈"></a>DFS 与栈</h3><p>多数情况下，在使用 BFS 的地方也可以使用 DFS，但它们的遍历顺序不同。DFS 所遍历得到的某一节点到另一节点的路径可能<strong>不是最短路径</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Return true if there is a path from cur to target.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">DFS</span><span class="params">(Node cur, Node target, Set&lt;Node&gt; visited)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span> <span class="keyword">if</span> cur is target;</span><br><span class="line">    <span class="keyword">for</span> (next : each neighbor of cur) &#123;</span><br><span class="line">        <span class="keyword">if</span> (next is not in visited) &#123;</span><br><span class="line">            add next to visted;</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">true</span> <span class="keyword">if</span> <span class="title">DFS</span><span class="params">(next, target, visited)</span> </span>== <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事实上，在调用 DFS 时，并没有显式地使用栈，而是使用了系统提供的所谓<strong>调用栈</strong>。</p>
<h3 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h3><div align="center"><img src="/images/2018/12/dfs-struct.png" width="60%"></div>

<p>每个节点的时间戳（发现时间、搜索完成时间）提供了图结构的重要信息。其所具有的括号化结构能够帮助我们判定各边属性。</p>
<h4 id="括号化定理"><a href="#括号化定理" class="headerlink" title="括号化定理"></a>括号化定理</h4><ul>
<li>区间 <code>[u.d, u.f]</code> 和区间 <code>[v.d, v.f]</code> 完全分离，在深度优先森林中，节点 <code>u</code> 不是节点 <code>v</code> 的后代，反之也不是。</li>
<li>区间 <code>[u.d, u.f]</code> 完全包含在区间 <code>[v.d, v.f]</code> 内，在深度优先树中，节点 <code>u</code> 是节点 <code>v</code> 的后代。</li>
<li>区间 <code>[v.d, v.f]</code> 完全包含在区间 <code>[u.d, u.f]</code> 内，在深度优先树中，节点 <code>v</code> 是节点 <code>u</code> 的后代。</li>
</ul>
<div align="center"><img src="/images/2018/12/dfs-time.png" width="50%"></div>

<h3 id="DFS-Tree"><a href="#DFS-Tree" class="headerlink" title="DFS Tree"></a>DFS Tree</h3><h4 id="边的类型"><a href="#边的类型" class="headerlink" title="边的类型"></a>边的类型</h4><ol>
<li><strong>树边</strong>：深度优先森林中的边。如果节点 <code>v</code> 是因算法对边 <code>(u, v)</code> 的探索而首先发现，则 <code>(u, v)</code> 是一条树边。</li>
<li><strong>后向边</strong>：后向边 <code>(u, v)</code> 是将节点 <code>u</code> 连接到其在深度优先树中（一个）祖先节点 <code>v</code> 的边。自循环也被认为是后向边。</li>
<li><strong>前向边</strong>：是将节点 <code>u</code> 连接到其在深度优先树中一个后代节点 <code>v</code> 的边 <code>(u, v)</code>。</li>
<li><strong>横向边</strong>：其他所有的边。这些边可以连接同一棵深度优先树中的节点，只要其中一个节点不是另外一个节点的祖先，也可以连接不同深度优先树中的两个节点。</li>
</ol>
<p>当遇到某些边时，DFS 有足够的信息对边分类。第一次探索边 <code>(u, v)</code> 时，节点 <code>v</code> 的颜色决定了该边的分类：</p>
<ol>
<li>节点 <code>v</code> 为白色表明该条边 <code>(u, v)</code> 是一条树边。</li>
<li>节点 <code>v</code> 为灰色表明该条边 <code>(u, v)</code> 是一条后向边。</li>
<li>节点 <code>v</code> 为黑色表明该条边 <code>(u, v)</code> 是一条前向边或衡向边。其中，<code>u.d &lt; v.d</code> 时为前向边，<code>u.d &gt; v.d</code> 时为衡向边。</li>
</ol>
<p>在对无向图的 DFS 中，不会出现前向边和横向边。</p>
<h1 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h1><h2 id="310-Minimum-Height-Trees"><a href="#310-Minimum-Height-Trees" class="headerlink" title="310 Minimum Height Trees"></a>310 Minimum Height Trees</h2><p><a href="https://leetcode.com/problems/minimum-height-trees/" target="_blank" rel="noopener">310. Minimum Height Trees</a></p>
<blockquote>
<p>For an undirected graph with tree characteristics, we can choose any node as the root. The result graph is then a rooted tree. Among all possible rooted trees, those with minimum height are called minimum height trees (MHTs). Given such a graph, write a function to find all the MHTs and return a list of their root labels.<br><strong>Format：</strong><br>The graph contains <code>n</code> nodes which are labeled from <code>0</code> to <code>n - 1</code>. You will be given the number n and a list of undirected <code>edges</code> (each edge is a pair of labels).<br>You can assume that no duplicate edges will appear in <code>edges</code>. Since all edges are undirected, <code>[0, 1]</code> is the same as <code>[1, 0]</code> and thus will not appear together in <code>edges</code>.<br><strong>Example：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 6, edges = [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]]</span><br><span class="line"></span><br><span class="line">     0  1  2</span><br><span class="line">      \ | /</span><br><span class="line">        3</span><br><span class="line">        |</span><br><span class="line">        4</span><br><span class="line">        |</span><br><span class="line">        5 </span><br><span class="line"></span><br><span class="line">Output: [3, 4]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>又是一道 Brute Force 很容易想到、但有多种优化方式的题。肯定不能每个节点遍历一遍去计算，就要想到 Minimum Height Trees (MHT) 的根节点有什么特点。这是个看上去很容易理解的道理：一根绳子从哪个位置拎起来下垂的长度更短？显然，答案是中间。对应到这棵树上，就是<strong>最长路径</strong>的中间节点（可能有两个）。</p>
<h3 id="如何找到最长路径？"><a href="#如何找到最长路径？" class="headerlink" title="如何找到最长路径？"></a>如何找到最长路径？</h3><p>可以通过两次遍历（DFS/BFS）确定最长路径。第一次遍历前，从随意选取的某一个端点（可能不是最长路径的一端）<code>x</code> 开始遍历，找到以它为端点的最长路径 <code>x..u</code>，<code>u</code> 就是整棵树最长路径的一个端点。可以用反证法说明，注意：树中两个端点间只有一条路径。这时以 <code>u</code> 为起点执行第二次遍历，找到以 <code>u</code> 为端点的最长路径 <code>u..v</code>，这也是整棵树的最长路径。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> n, List&lt;List&lt;Integer&gt;&gt; neighbors, <span class="keyword">int</span>[] parents, <span class="keyword">int</span>[] levels)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Normal bfs recording levels for each node</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findMinHeightTrees</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] edges)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.asList(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; neighbors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        neighbors.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.length; i++) &#123;</span><br><span class="line">        neighbors.get(edges[i][<span class="number">0</span>]).add(edges[i][<span class="number">1</span>]);</span><br><span class="line">        neighbors.get(edges[i][<span class="number">1</span>]).add(edges[i][<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] parents = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">int</span>[] levels = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"></span><br><span class="line">    bfs(<span class="number">0</span>, n, neighbors, parents, levels);</span><br><span class="line">    <span class="keyword">int</span> u = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (levels[i] &gt; levels[u]) &#123;</span><br><span class="line">            u = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bfs(u, n, neighbors, parents, levels);</span><br><span class="line">    <span class="keyword">int</span> v = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (levels[i] &gt; levels[v]) &#123;</span><br><span class="line">            v = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Integer&gt; longestPath = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (v != -<span class="number">1</span>) &#123;</span><br><span class="line">        longestPath.add(v);</span><br><span class="line">        v = parents[v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> size = longestPath.size();</span><br><span class="line">    <span class="keyword">return</span> (size % <span class="number">2</span> == <span class="number">0</span>) ? Arrays.asList(longestPath.get(size / <span class="number">2</span> - <span class="number">1</span>), longestPath.get(size / <span class="number">2</span>)) : Arrays.asList(longestPath.get(size / <span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="通过一次遍历确定中间点"><a href="#通过一次遍历确定中间点" class="headerlink" title="通过一次遍历确定中间点"></a>通过一次遍历确定中间点</h3><p>对于最简单的情形（有 <code>n</code> 个节点的线图），只需指定两个指针分别从两个端点出发，以相同速度靠近，如果两指针重合或只差一步，就找到了中间点（可能是两个）。</p>
<p>将这种「双指针」的思想应用于树，从每个<strong>叶子节点</strong>开始（叶子节点是度为1的节点），每个迭代步删去所有当前的叶子节点（对应于在邻接矩阵上删去这一节点），直到仅剩1个或2个节点——他们都是 MHT 的根节点。其实，在这一过程中被删去的节点都<em>不可能</em>是 MHT 的根节点，因为<strong>它的邻居作为 MHT 的根节点时总能使树高度更短</strong>。</p>
<p><div align="center"><img src="/images/2018/12/mht.jpeg" width="50%"></div></p>
<center>「农村包围城市」</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findMinHeightTrees</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] edges)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> Collections.singletonList(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    List&lt;Set&lt;Integer&gt;&gt; adj = <span class="keyword">new</span> ArrayList&lt;&gt;(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) adj.add(<span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] edge : edges) &#123;</span><br><span class="line">        adj.get(edge[<span class="number">0</span>]).add(edge[<span class="number">1</span>]);</span><br><span class="line">        adj.get(edge[<span class="number">1</span>]).add(edge[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; leaves = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (adj.get(i).size() == <span class="number">1</span>) leaves.add(i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        n -= leaves.size();</span><br><span class="line">        List&lt;Integer&gt; newLeaves = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : leaves) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = adj.get(i).iterator().next();</span><br><span class="line">            adj.get(j).remove(i);</span><br><span class="line">            <span class="keyword">if</span> (adj.get(j).size() == <span class="number">1</span>) newLeaves.add(j);</span><br><span class="line">        &#125;</span><br><span class="line">        leaves = newLeaves;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> leaves;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="417-Pacific-Atlantic-Water-Flow"><a href="#417-Pacific-Atlantic-Water-Flow" class="headerlink" title="417 Pacific Atlantic Water Flow"></a>417 Pacific Atlantic Water Flow</h2><p><a href="https://leetcode.com/problems/pacific-atlantic-water-flow/" target="_blank" rel="noopener">417. Pacific Atlantic Water Flow</a></p>
<blockquote>
<p>Given an <code>m x n</code> matrix of non-negative integers representing the height of each unit cell in a continent, the “Pacific ocean” touches the left and top edges of the matrix and the “Atlantic ocean” touches the right and bottom edges.<br>Water can only flow in four directions (up, down, left, or right) from a cell to another one with height equal or lower.<br>Find the list of grid coordinates where water can flow to both the Pacific and Atlantic ocean.</p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
<ol>
<li>The order of returned grid coordinates does not matter.</li>
<li>Both m and n are less than 150.</li>
</ol>
</blockquote>
<blockquote>
<p><strong>Example</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Given the following 5x5 matrix:</span><br><span class="line"></span><br><span class="line">  Pacific ~   ~   ~   ~   ~ </span><br><span class="line">       ~  1   2   2   3  (5) *</span><br><span class="line">       ~  3   2   3  (4) (4) *</span><br><span class="line">       ~  2   4  (5)  3   1  *</span><br><span class="line">       ~ (6) (7)  1   4   5  *</span><br><span class="line">       ~ (5)  1   1   2   4  *</span><br><span class="line">          *   *   *   *   * Atlantic</span><br><span class="line"></span><br><span class="line">Return:</span><br><span class="line"></span><br><span class="line">[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (positions with parentheses in above matrix).</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="确定遍历的起始点和方向"><a href="#确定遍历的起始点和方向" class="headerlink" title="确定遍历的起始点和方向"></a>确定遍历的起始点和方向</h3><p>直接想到的方法是从<strong>每个点</strong>出发 DFS，如果到达 Pacific 或 Atlantic 就记录下来，最后扫描一遍检查符合要求的点。但这种方法 TLE。想到可以从另一个方向「反向」地 DFS。事实上，DFS 的起点是自定义的，在无向图中没有区分。仔细确定 DFS 执行的起点，可以影响算法的效率。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] moves = <span class="keyword">new</span> <span class="keyword">int</span>[][] &#123;&#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line">    <span class="keyword">public</span> List&lt;<span class="keyword">int</span>[]&gt; pacificAtlantic(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">        m = matrix.length;</span><br><span class="line">        n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span>[][] reachA = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">boolean</span>[][] reachB = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            dfs(i, <span class="number">0</span>, matrix, reachA);</span><br><span class="line">            dfs(i, n - <span class="number">1</span>, matrix, reachB);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            dfs(<span class="number">0</span>, j, matrix, reachA);</span><br><span class="line">            dfs(m - <span class="number">1</span>, j, matrix, reachB);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (reachA[i][j] &amp;&amp; reachB[i][j]) &#123;</span><br><span class="line">                    ret.add(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;i, j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">int</span>[][] matrix, <span class="keyword">boolean</span>[][] canReach)</span> </span>&#123;</span><br><span class="line">        canReach[r][c] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] move : moves) &#123;</span><br><span class="line">            <span class="keyword">int</span> rMove = r + move[<span class="number">0</span>], cMove = c + move[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (rMove &gt;= <span class="number">0</span> &amp;&amp; rMove &lt; m &amp;&amp; cMove &gt;= <span class="number">0</span> &amp;&amp; cMove &lt; n &amp;&amp; !canReach[rMove][cMove] &amp;&amp; matrix[r][c] &lt;= matrix[rMove][cMove]) &#123;</span><br><span class="line">                dfs(rMove, cMove, matrix, canReach);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述算法也可以改成 BFS。BFS 只需在起始时分别将海岸线<strong>一次性地</strong>加入队列中，算法执行时在每一层就<strong>扩大</strong>覆盖的区域的<strong>边界</strong>。</p>
<p>确定遍历起始点的重要性在另外一些题中也有体现。以下两题都反映了这种思想。</p>
<h2 id="130-Surrounded-Regions"><a href="#130-Surrounded-Regions" class="headerlink" title="130 Surrounded Regions"></a>130 Surrounded Regions</h2><p><a href="https://leetcode.com/problems/surrounded-regions/" target="_blank" rel="noopener">130. Surrounded Regions</a></p>
<blockquote>
<p>Given a 2D board containing <code>&#39;X&#39;</code> and <code>&#39;O&#39;</code> (the letter O), capture all regions surrounded by <code>&#39;X&#39;</code>.<br>A region is captured by flipping all <code>&#39;O&#39;</code>s into <code>&#39;X&#39;</code>s in that surrounded region.</p>
</blockquote>
<blockquote>
<p><strong>Example:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X X X X</span><br><span class="line">X O O X</span><br><span class="line">X X O X</span><br><span class="line">X O X X</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>After running your function, the board should be:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X O X X</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Explanation:</strong><br>Surrounded regions shouldn’t be on the border, which means that any ‘O’ on the border of the board are not flipped to ‘X’. Any ‘O’ that is not on the border and it is not connected to an ‘O’ on the border will be flipped to ‘X’. Two cells are connected if they are adjacent cells connected horizontally or vertically.</p>
</blockquote>
<p>对边界上的 <code>O</code> 点执行 DFS，访问到的 <code>O</code> 点都更改为 <code>1</code>。所有边界上的点都探索并执行 DFS 完毕后，将标记过的点改为 <code>O</code> 其他点不变或改为 <code>X</code>。参考代码在<a href="https://leetcode.com/problems/surrounded-regions/discuss/41612" target="_blank" rel="noopener">这里</a>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X X X X           X X X X             X X X X</span><br><span class="line">X X O X  -&gt;       X X O X    -&gt;       X X X X</span><br><span class="line">X O X X           X 1 X X             X O X X</span><br><span class="line">X O X X           X 1 X X             X O X X</span><br></pre></td></tr></table></figure>
<h2 id="542-01-Matrix"><a href="#542-01-Matrix" class="headerlink" title="542 01 Matrix"></a>542 01 Matrix</h2><p><a href="https://leetcode.com/problems/01-matrix/" target="_blank" rel="noopener">542. 01 Matrix</a></p>
<blockquote>
<p>Given a matrix consists of 0 and 1, find the distance of the nearest 0 for each cell.]<br>The distance between two adjacent cells is 1.<br><strong>Example 2</strong>:<br><strong>Input</strong>:<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 0 0</span><br><span class="line">0 1 0</span><br><span class="line">1 1 1</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Output</strong>:<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 0 0</span><br><span class="line">0 1 0</span><br><span class="line">1 2 1</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
<ol>
<li>The number of elements of the given matrix will not exceed 10,000.</li>
<li>There are at least one 0 in the given matrix.</li>
<li>The cells are adjacent in only four directions: up, down, left and right.</li>
</ol>
</blockquote>
<h3 id="用-BFS-计算最短距离"><a href="#用-BFS-计算最短距离" class="headerlink" title="用 BFS 计算最短距离"></a>用 BFS 计算最短距离</h3><p>使用 BFS 解决这种需要计算<strong>最短距离</strong>的问题。总体思路是：</p>
<ol>
<li>在执行 BFS 之前，遍历矩阵将值为 0 的元素入列，其他元素值修改为 <code>Integer.MAX_VALUE</code>。</li>
<li>在访问每个节点时，对四个相邻的点比较它们自身的值 <code>val</code> 和 <strong><code>cal_dist</code> = 当前点距离 + 1</strong> 的大小，如果 <code>val &gt; cal_dist</code> 就修改 <code>val</code> 为 <code>cal_dist</code>，并入队待下一轮访问。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] updateMatrix(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">    <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">    <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">    </span><br><span class="line">    Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;i, j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                matrix[i][j] = Integer.MAX_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>[][] dirs = &#123;&#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] cell = queue.poll();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] d : dirs) &#123;</span><br><span class="line">            <span class="keyword">int</span> r = cell[<span class="number">0</span>] + d[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> c = cell[<span class="number">1</span>] + d[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (r &lt; <span class="number">0</span> || r &gt;= m || c &lt; <span class="number">0</span> || c &gt;= n || </span><br><span class="line">                matrix[r][c] &lt;= matrix[cell[<span class="number">0</span>]][cell[<span class="number">1</span>]] + <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;r, c&#125;);</span><br><span class="line">            matrix[r][c] = matrix[cell[<span class="number">0</span>]][cell[<span class="number">1</span>]] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> matrix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="动态规划方法"><a href="#动态规划方法" class="headerlink" title="动态规划方法"></a>动态规划方法</h3><p>动态规划分为两边整体扫描。用一个二维数组保存当前的 <code>distance</code>：</p>
<ol>
<li>第一遍扫描方向为从左到右，从上到下。扫描时在 <code>distance</code> 数组中赋值，如果当前点值不为 0，更新它为 <code>dis[i][j] = min(dis[i - 1][j], dis[i][j - 1]) + 1</code>。扫描完成后，每个节点都保存了距离左和上方向值为 0 的点的距离。</li>
<li>第二遍扫描方向为从右到左，从下到上。如果当前点值不为 0，更新它为 <code>dis[i][j] = min(min(dis[i + 1][j], dis[i][j + 1]) + 1, dis[i][j])</code>。</li>
<li>两边扫描结束后，<code>distance</code> 数组中保存了每个点的所求距离。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0 ... . ... 0</span><br><span class="line">.     .     .</span><br><span class="line">. ... 1 ... .</span><br><span class="line">.     ~     .</span><br><span class="line">0 *** * ... 0</span><br></pre></td></tr></table></figure>
<p>可以如上图分别考虑「目标 0 点」在四个不同方向时，两边扫描都可以覆盖它们的最短路径（两条<strong>折一次</strong>的最短路径之一）。以左下角的 0 为例说明（假设 1 点对应的最近 0 点为左下角的点）：第一次扫描，可以确定 <code>distance</code> 数组中 <code>*</code> 路径上的点所对应的值为<strong>最终值</strong>；第二次扫描后可以确定 <code>~</code> 点对应值为最终值。经过两次扫描后，1 所在位置在数组中对应的值也为最终值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] updateMatrix(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> matrix;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[][] dis = <span class="keyword">new</span> <span class="keyword">int</span>[matrix.length][matrix[<span class="number">0</span>].length];</span><br><span class="line">    <span class="keyword">int</span> range = matrix.length * matrix[<span class="number">0</span>].length;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                dis[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> upCell = (i &gt; <span class="number">0</span>) ? dis[i - <span class="number">1</span>][j] : range;</span><br><span class="line">                <span class="keyword">int</span> leftCell = (j &gt; <span class="number">0</span>) ? dis[i][j - <span class="number">1</span>] : range;</span><br><span class="line">                dis[i][j] = Math.min(upCell, leftCell) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = matrix.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = matrix[<span class="number">0</span>].length - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                dis[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> downCell = (i &lt; matrix.length - <span class="number">1</span>) ? dis[i + <span class="number">1</span>][j] : range;</span><br><span class="line">                <span class="keyword">int</span> rightCell = (j &lt; matrix[<span class="number">0</span>].length - <span class="number">1</span>) ? dis[i][j + <span class="number">1</span>] : range;</span><br><span class="line">                dis[i][j] = Math.min(Math.min(downCell, rightCell) + <span class="number">1</span>, dis[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dis;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="199-Binary-Tree-Right-Side-View"><a href="#199-Binary-Tree-Right-Side-View" class="headerlink" title="199 Binary Tree Right Side View"></a>199 Binary Tree Right Side View</h2><p><a href="https://leetcode.com/problems/binary-tree-right-side-view/" target="_blank" rel="noopener">199. Binary Tree Right Side View</a></p>
<blockquote>
<p>Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,null,5,null,4]</span><br><span class="line">Output: [1, 3, 4]</span><br><span class="line">Explanation:</span><br><span class="line"></span><br><span class="line">   1            &lt;---</span><br><span class="line"> /   \</span><br><span class="line">2     3         &lt;---</span><br><span class="line"> \     \</span><br><span class="line">  5     4       &lt;---</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>最容易想到的方法是通过 BFS 访问每一层的节点，自左向右地加入队列。在每一层计数，最后一个节点为 Right Side View 节点。也可称为层次遍历。</p>
<p><a href="https://leetcode.com/problems/binary-tree-right-side-view/discuss/56012" target="_blank" rel="noopener">另一种思路</a>更为简洁，也很容易理解：使用递归的方式将当前节点的<strong>深度</strong>作为参数传递，函数的内部先递归地访问右子节点，再访问左子节点。在<strong>每一个深度</strong>，只有第一个访问的节点被加入到输出数组中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    rightView(root, result, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rightView</span><span class="params">(TreeNode curr, List&lt;Integer&gt; result, <span class="keyword">int</span> currDepth)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(curr == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(currDepth == result.size())&#123;</span><br><span class="line">        result.add(curr.val);</span><br><span class="line">    &#125;</span><br><span class="line">    rightView(curr.right, result, currDepth + <span class="number">1</span>);</span><br><span class="line">    rightView(curr.left, result, currDepth + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="116-Populating-Next-Right-Pointers-in-Each-Node"><a href="#116-Populating-Next-Right-Pointers-in-Each-Node" class="headerlink" title="116 Populating Next Right Pointers in Each Node"></a>116 Populating Next Right Pointers in Each Node</h2><p><a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node/" target="_blank" rel="noopener">116. Populating Next Right Pointers in Each Node</a></p>
<blockquote>
<p>Given a binary tree<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct TreeLinkNode &#123;</span><br><span class="line">  TreeLinkNode *left;</span><br><span class="line">  TreeLinkNode *right;</span><br><span class="line">  TreeLinkNode *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code>NULL</code>.<br>Initially, all next pointers are set to <code>NULL</code>.</p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
<ul>
<li>You may only use constant extra space.</li>
<li>Recursive approach is fine, implicit stack space does not count as extra space for this problem.</li>
<li>You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).</li>
</ul>
</blockquote>
<blockquote>
<p>Given the following perfect binary tree,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     1</span><br><span class="line">   /  \</span><br><span class="line">  2    3</span><br><span class="line"> / \  / \</span><br><span class="line">4  5  6  7</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>After calling your function, the tree should look like:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     1 -&gt; NULL</span><br><span class="line">   /  \</span><br><span class="line">  2 -&gt; 3 -&gt; NULL</span><br><span class="line"> / \  / \</span><br><span class="line">4-&gt;5-&gt;6-&gt;7 -&gt; NULL</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h3><p>递归地访问每个节点时，连接该节点的左子节点到右子节点，连接右子节点到该节点的 next 节点（如有）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(TreeLinkNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        root.left.next = root.right;</span><br><span class="line">        <span class="keyword">if</span> (root.next != <span class="keyword">null</span>)</span><br><span class="line">            root.right.next = root.next.left;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    connect(root.left);</span><br><span class="line">    connect(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="非递归方法"><a href="#非递归方法" class="headerlink" title="非递归方法"></a>非递归方法</h3><p>迭代的方法相当于按层次遍历每个节点，在访问每个节点时，连接其左右子节点。外层以层为单位，依次访问每一层的最左节点，由于访问一层的每个节点时，该层所有节点的 next 节点都已就绪，所以遍历时只需通过 <code>cur = cur.next</code> 访问下一个节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(TreeLinkNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    TreeLinkNode cur = root;</span><br><span class="line">    <span class="keyword">while</span> (cur.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        TreeLinkNode nextLeftmost = cur.left;  <span class="comment">// save the start of next level</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cur.left.next = cur.right;</span><br><span class="line">            cur.right.next = cur.next == <span class="keyword">null</span> ? <span class="keyword">null</span> : cur.next.left;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = nextLeftmost;  <span class="comment">// point to next level </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="117-Populating-Next-Right-Pointers-in-Each-Node-II"><a href="#117-Populating-Next-Right-Pointers-in-Each-Node-II" class="headerlink" title="117 Populating Next Right Pointers in Each Node II"></a>117 Populating Next Right Pointers in Each Node II</h2><p><a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/" target="_blank" rel="noopener">117. Populating Next Right Pointers in Each Node II</a></p>
<blockquote>
<p>Given the following binary tree,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     1</span><br><span class="line">   /  \</span><br><span class="line">  2    3</span><br><span class="line"> / \    \</span><br><span class="line">4   5    7</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>After calling your function, the tree should look like:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     1 -&gt; NULL</span><br><span class="line">   /  \</span><br><span class="line">  2 -&gt; 3 -&gt; NULL</span><br><span class="line"> / \    \</span><br><span class="line">4-&gt; 5 -&gt; 7 -&gt; NULL</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="非递归方法-1"><a href="#非递归方法-1" class="headerlink" title="非递归方法"></a>非递归方法</h3><p>在 116 题中非递归方法的算法基础上修改。</p>
<p>迭代地访问每一层节点，访问每个节点时，处理其左右子节点的连接。但由于每个节点的子节点情况不再固定，因此需要用其他方法<strong>按层遍历节点</strong>。两者另一显著区别是：本题中无法确定每（下）一层的<strong>最左节点</strong>。于是通过一个桩节点 <code>dummyNode</code> 来指向在每一层<strong>第一个访问到</strong>的节点。</p>
<p><code>cur</code> 为当前层的移动指针；<code>p</code> 为下一层的移动指针。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(TreeLinkNode root)</span> </span>&#123;</span><br><span class="line">    TreeLinkNode dummyNode = <span class="keyword">new</span> TreeLinkNode(-<span class="number">1</span>);</span><br><span class="line">    TreeLinkNode cur = root;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        TreeLinkNode p = dummyNode;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                p.next = cur.left;  <span class="comment">// link p.next</span></span><br><span class="line">                p = p.next;  <span class="comment">// jump to next node</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                p.next = root.right;  <span class="comment">// link p.next</span></span><br><span class="line">                p = p.next;  <span class="comment">// jump to next node</span></span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = dummyNode.next;  <span class="comment">// move to next level left most</span></span><br><span class="line">        dummyNode.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/leetcode/" rel="tag"># leetcode</a>
          
            <a href="/tags/DFS/" rel="tag"># DFS</a>
          
            <a href="/tags/BFS/" rel="tag"># BFS</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/12/02/recursion/" rel="next" title="[LeetCode] Recursion">
                <i class="fa fa-chevron-left"></i> [LeetCode] Recursion
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/03/02/stack/" rel="prev" title="[LeetCode] Stack">
                [LeetCode] Stack <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Sheffield</p>
              <p class="site-description motion-element" itemprop="description">Sheffield Ge 的技术博客</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">25</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/xfge" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:xfge.cn@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i></a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#基本概念"><span class="nav-text">基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#BFS"><span class="nav-text">BFS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#BFS-与队列"><span class="nav-text">BFS 与队列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DFS"><span class="nav-text">DFS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#DFS-与栈"><span class="nav-text">DFS 与栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#时间戳"><span class="nav-text">时间戳</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#括号化定理"><span class="nav-text">括号化定理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DFS-Tree"><span class="nav-text">DFS Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#边的类型"><span class="nav-text">边的类型</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#相关问题"><span class="nav-text">相关问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#310-Minimum-Height-Trees"><span class="nav-text">310 Minimum Height Trees</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#如何找到最长路径？"><span class="nav-text">如何找到最长路径？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通过一次遍历确定中间点"><span class="nav-text">通过一次遍历确定中间点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#417-Pacific-Atlantic-Water-Flow"><span class="nav-text">417 Pacific Atlantic Water Flow</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#确定遍历的起始点和方向"><span class="nav-text">确定遍历的起始点和方向</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#130-Surrounded-Regions"><span class="nav-text">130 Surrounded Regions</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#542-01-Matrix"><span class="nav-text">542 01 Matrix</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#用-BFS-计算最短距离"><span class="nav-text">用 BFS 计算最短距离</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动态规划方法"><span class="nav-text">动态规划方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#199-Binary-Tree-Right-Side-View"><span class="nav-text">199 Binary Tree Right Side View</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#116-Populating-Next-Right-Pointers-in-Each-Node"><span class="nav-text">116 Populating Next Right Pointers in Each Node</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#递归方法"><span class="nav-text">递归方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#非递归方法"><span class="nav-text">非递归方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#117-Populating-Next-Right-Pointers-in-Each-Node-II"><span class="nav-text">117 Populating Next Right Pointers in Each Node II</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#非递归方法-1"><span class="nav-text">非递归方法</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sheffield</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
